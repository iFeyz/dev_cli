use alloy::{
    primitives::{U256, Bytes, LogData, Log}, // Use LogData from primitives, not rpc::types::Log
    sol_types::{SolCall, SolEvent, SolInterface, SolConstructor, SolEventInterface},
};

use alloy::sol;

use crate::model::interaction::{RequestError, RequestResult};

use crate::contract::contract_interface::ContractData;

// Define the Solidity contract interface using Alloy's sol! macro
sol! {
    #[derive(Debug)]
    contract SimpleStorage {
        // Storage variable
        uint256 public storedNumber;
        
        // Events
        event NumberSet(uint256 indexed newNumber, address indexed setter);
        
        // Constructor
        constructor(uint256 _initialValue);
        
        // Functions
        function setNumber(uint256 _number) public;
        function getNumber() public view returns (uint256);
        function increment() public;
        function decrement() public;
    }
}

// Contract bytecode (this would normally be generated by compiling the Solidity contract)
// This is a simplified bytecode for demonstration
const SIMPLE_STORAGE_BYTECODE: &[u8] = &[
    0x60, 0x80, 0x60, 0x40, 0x52, 0x34, 0x80, 0x15, 0x61, 0x00, 0x10, 0x57, 0x60, 0x00, 0x80, 0xfd,
    0x5b, 0x50, 0x60, 0x04, 0x36, 0x10, 0x61, 0x00, 0x3c, 0x57, 0x60, 0x00, 0x35, 0x7c, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x04, 0x63, 0xff, 0xff,
    0xff, 0xff, 0x16, 0x80, 0x63, 0x3f, 0xb5, 0xc1, 0xc6, 0x14, 0x61, 0x00, 0x41, 0x57, 0x80, 0x63,
    0xf2, 0xfd, 0xe3, 0x8b, 0x14, 0x61, 0x00, 0x5f, 0x57, 0x5b, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x34,
    0x80, 0x15, 0x61, 0x00, 0x4d, 0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x61, 0x00, 0x5a, 0x61,
    0x00, 0x7d, 0x56, 0x5b, 0x60, 0x40, 0x51, 0x80, 0x82, 0x81, 0x52, 0x60, 0x20, 0x01, 0x91, 0x50,
    0x50, 0x60, 0x40, 0x51, 0x80, 0x91, 0x03, 0x90, 0xf3, 0x5b, 0x34, 0x80, 0x15, 0x61, 0x00, 0x6b,
    0x57, 0x60, 0x00, 0x80, 0xfd, 0x5b, 0x50, 0x61, 0x00, 0x7b, 0x60, 0x04, 0x80, 0x36, 0x03, 0x81,
    0x01, 0x90, 0x80, 0x35, 0x90, 0x60, 0x20, 0x01, 0x90, 0x91, 0x90, 0x50, 0x50, 0x61, 0x00, 0x83,
    0x56, 0x5b, 0x00, 0x5b, 0x60, 0x00, 0x54, 0x90, 0x56, 0x5b, 0x80, 0x60, 0x00, 0x81, 0x90, 0x55,
    0x50, 0x50, 0x56
];

const SIMPLE_STORAGE_ABI: &str = r#"[
    {
        "type": "constructor",
        "inputs": [{"name": "_initialValue", "type": "uint256"}],
        "stateMutability": "nonpayable"
    },
    {
        "type": "function",
        "name": "storedNumber",
        "inputs": [],
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view"
    },
    {
        "type": "function",
        "name": "setNumber",
        "inputs": [{"name": "_number", "type": "uint256"}],
        "outputs": [],
        "stateMutability": "nonpayable"
    },
    {
        "type": "function",
        "name": "getNumber",
        "inputs": [],
        "outputs": [{"name": "", "type": "uint256"}],
        "stateMutability": "view"
    },
    {
        "type": "function",
        "name": "increment",
        "inputs": [],
        "outputs": [],
        "stateMutability": "nonpayable"
    },
    {
        "type": "function",
        "name": "decrement",
        "inputs": [],
        "outputs": [],
        "stateMutability": "nonpayable"
    },
    {
        "type": "event",
        "name": "NumberSet",
        "inputs": [
            {"name": "newNumber", "type": "uint256", "indexed": true},
            {"name": "setter", "type": "address", "indexed": true}
        ]
    }
]"#;

// Implement ContractData for SimpleStorage using the generated types
pub struct SimpleStorageContract;

impl ContractData for SimpleStorageContract {
    type Calls = SimpleStorage::SimpleStorageCalls;
    type Events = SimpleStorage::SimpleStorageEvents;
    type ConstructorCall = SimpleStorage::constructorCall;

    const NAME: &'static str = "SimpleStorage";
    const BYTECODE: &'static [u8] = SIMPLE_STORAGE_BYTECODE;
    const ABI: &'static str = SIMPLE_STORAGE_ABI;
    
    // Implémentation des méthodes d'encodage/décodage
    fn encode_call(call: &Self::Calls) -> Bytes {
        // SimpleStorageCalls implémente SolInterface
        Bytes::from(call.abi_encode())
    }
    
    fn decode_event(log_data: &LogData) -> Result<Self::Events, RequestError> {
        // Convertir LogData en Log pour decode_log
        // Note: Nous n'avons pas l'adresse ici, donc on utilise une adresse par défaut
        let log = Log {
            address: alloy::primitives::Address::ZERO, // Adresse par défaut
            data: log_data.clone(),
        };
        
        Self::Events::decode_log(&log)
            .map(|log| log.data)
            .map_err(|e| RequestError::ContractError(format!("Failed to decode event: {}", e)))
    }

    fn encode_constructor(constructor: &Self::ConstructorCall) -> Bytes {
        // Le constructeur implémente SolCall
        Bytes::from(constructor.abi_encode())
    }
}

// Helper functions for interacting with the contract
impl SimpleStorageContract {
    pub fn set_number_call(number: U256) -> SimpleStorage::SimpleStorageCalls {
        SimpleStorage::SimpleStorageCalls::setNumber(SimpleStorage::setNumberCall { _number: number })
    }

    pub fn get_number_call() -> SimpleStorage::SimpleStorageCalls {
        SimpleStorage::SimpleStorageCalls::getNumber(SimpleStorage::getNumberCall {})
    }

    pub fn increment_call() -> SimpleStorage::SimpleStorageCalls {
        SimpleStorage::SimpleStorageCalls::increment(SimpleStorage::incrementCall {})
    }

    pub fn decrement_call() -> SimpleStorage::SimpleStorageCalls {
        SimpleStorage::SimpleStorageCalls::decrement(SimpleStorage::decrementCall {})
    }

    pub fn constructor_call(initial_value: U256) -> SimpleStorage::constructorCall {
        SimpleStorage::constructorCall { _initialValue: initial_value }
    }
}